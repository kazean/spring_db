# 5. 자바 예외 이해
## 1. 예외 계층
자바 기본 예외에 대한 이해 필요
- 예외 계층 그림
> Object > Throwable > Exception / Error > Exception ( SQLException, IOException) / RuntimeExpcetion ( NullPointerException, IllegalArugumentException)
>> Error: 복구 불가능한 시스템 예외, 개발자는 이 예외를 잡으려 하면 안된다.  
Exception: 체크예외, 애플리케이션 로직에서 사용할 수 있는 실질적인 최상위 예외이다.  
RuntimeException: 언체크 예외, 런타임 예외

## 2. 예외 기본 규칙
잡아서 처리하거나, 처리할 수 없으면 밖으로 던져야 한다.
-
## 3. 체크 예외 기본 이해
- Exception과 그 하위 예외는 컴파일러가 체크하는 `체크 예외`, 단 RuntimeException은 예외로 한다.  
체크 예외는 잡아서 처리하거나, 던지도록 아니면 컴파일 오류가 발생
- CheckedTest
> Exception을 상속받은 예외는 체크 예외가 된다, RuntimeException 언체크 예외  
오류 메세지를 보관하는 기능, 생성자를 통해서 메세지 전달  
`예외에 대한 스택 트레이스 추가`: 마지막 인수에 예외 객체를 전달해주면 로그가 해당 예외의 스택 트레이스를 추가로 출력  
log.info("예외처리, message={}", e.getMessage(), e);
- 체크 예외의 장단점
> 예외를 처리할 수 없을때 throws 예외 필수로 선언  
그렇지 않으면 컴파일 오류: 장단점이 동시에 존재

## 4. 언체크 예외 기본 이해
- `RuntimeException과 그 하위 예외는 언체크 예외로 분류`  
컴파일러가 예외를 체크하지 않는다는 뜻  
throws를 선언하지 않고 예외 생략할 수 있다
- 체크 예외 vs 언체크 예외: throws 생략 여부
- UnCheckedTest
> throws 생략, 중요 예외인 경우 선언해두면 개발자가 IDE를 통해 확인 가능
- 언체크 예외 장단점
> 장점: 신경쓰고 싶지 않은 언체크 예외 무시, 의존 관계를 참조하지 않아도 되는 장점  
단점: 개발자가 실수로 예외를 누락

## 5. 체크 예외 활용
- 기본원칙 2가지
1. 기본적으로 언체크(런타임) 예외를 사용하자.
2. 체크 예외는 비지니스 로직상 의도적으로 던지는 예외에만 사용하자 ex)계좌 이체 실패, 결제시 포인트 부족 예외
- 체크 예외 문제점
> 예외 전파
- 2가지 문제
1. 복구 불가능한 예외: SQLException 등 데이터베이스 문제라 서비스와 컨트롤러에서 해결할 수 없다.
2. 의존 관계에 대한 문제: JDBC 기술이 아닌 다른 기술로 변경(SQLEx > JPAEx)
> DI + OCP를 통해 클라이언트 코드의 변ㄱ녕 없이 대상 구현체를 변경할 수 있다는 장점이 체크 예외 때문에 발목을 잡게 된다.
- 정리
> 실무에서 발생하는 대부분의 예외들은 이런 시스템 예외들이다.  
체크 예외시, 불필요한 의존관계 문제가 발생

## 6. 언체크 예외 활용
- SQLEx > RuntimeSQLEx, ConnectEx > RuntimeConnectEx
- UnCheckedAppTest
> 예외 전환: 체크 예외인 SQLEx > RunitmeEx, 기존 예외를 포함해주어야 예외 출력시 스택 트레이스에서 기존 예외 확인 가능  
- 런타임 예외 - 대부분 복구 불가능한 예외
- 런타임 예외 - 의존 관계에 대한 문제
- 체크 예외 구현 기술 변경시 파급 효과
> 런타임 예외를 사용하면 중간에 기술이 변경 되어도 파급효과 X
- 정리
> 처음에 자바 설계할 당시 체크 예외가 더 나은 선택이라 생각, 최근 라이브러리들은 대부분 런타임 예외를 기본으로 제공
- 런타임 예외는 문서화

## 7. 예외 포함과 스택 트레이스
`예외를 전활할 때는 꼭 기존 예외를 포함 해야한다`
> log.info("ex", e): 마지막 e 인자  
throw new RuntimeSQLException(e)  
> !기존 예외를 포함하지 않는 경우  
예외를 포함하지 않아서 기존에 발생한 java.sql.SQLException과 스택 트레이스를 확인할 수 없다.
